Hello from C:\Users\StevensUser\.atom\packages\ide-reason\rls\rls-win32-1.4.1.exe
Previous log location: C:\Users\STEVEN~1\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"refmt":"refmt","lispRefmt":"lispRefmt","format_width":80,"autoRebuild":true,"per_value_codelens":false,"dependencies_codelens":false,"opens_codelens":false}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///C:/cygwin64/home/StevensUser/cs496/4_TypeCheck/ast.ml","languageId":"ocaml","version":1,"text":"(* The type of the abstract syntax tree (AST). *)\n\ntype expr =\n  | Var of string\n  | Int of int\n  | Unit\n  | Add of expr*expr\n  | Sub of expr*expr\n  | Mul of expr*expr\n  | Div of expr*expr\n  | Let of string*expr*expr\n  | IsZero of expr\n  | ITE of expr*expr*expr\n  | Proc of string*texpr*expr\n  | App of expr*expr\n  | Letrec of texpr*string*string*texpr*expr*expr\n  | Set of string*expr\n  | BeginEnd of expr list\n  | NewRef of expr\n  | DeRef of expr\n  | SetRef of expr*expr\n  (* pair *)\n  | Pair of expr*expr\n  | Unpair of string*string*expr*expr\n  (* list *)\n  | EmptyList of texpr\n  | Cons of expr*expr\n  | Null of expr\n  | Hd of expr\n  | Tl of expr\n  | Debug\n  (* tree *)\n  | EmptyTree of texpr\n  | Node of expr*expr*expr\n  | NullT of expr\n  | GetData of expr\n  | GetLST of expr\n  | GetRST of expr\nand\n  texpr =\n  | IntType\n  | BoolType\n  | UnitType\n  | FuncType of texpr*texpr\n  | RefType of texpr\n  | PairType of texpr*texpr\n  | ListType of texpr\n  | TreeType of texpr\n\ntype prog = AProg of expr\n\n\nlet rec string_of_expr e =\n  match e with\n  | Var s -> \"Var \"^s\n  | Int n -> \"Int \"^string_of_int n\n  | Unit -> \"Unit\"\n  | Add(e1,e2) -> \"Add(\" ^ (string_of_expr e1) ^ \",\" ^ string_of_expr e2 ^ \")\"\n  | Sub(e1,e2) -> \"Sub(\" ^ (string_of_expr e1) ^ \",\" ^ string_of_expr e2 ^ \")\"\n  | Mul(e1,e2) -> \"Mul(\" ^ (string_of_expr e1) ^ \",\" ^ string_of_expr e2 ^ \")\"\n  | Div(e1,e2) -> \"Div(\" ^ (string_of_expr e1) ^ \",\" ^ string_of_expr e2 ^ \")\"\n  (* Ref *)\n  | NewRef(e) -> \"NewRef(\" ^ (string_of_expr e) ^ \")\"\n  | DeRef(e) -> \"DeRef(\" ^ (string_of_expr e) ^ \")\"\n  | SetRef(e1,e2) -> \"SetRef(\" ^ (string_of_expr e1) ^ \",\" ^ string_of_expr e2 ^ \")\"\n  | Let(x,def,body) -> \"Let(\"^x^\",\"^string_of_expr def ^\",\"^ string_of_expr body ^\")\"\n  | Proc(x,t,body) -> \"Proc(\"^x^\":\"^string_of_texpr t^\",\" ^ string_of_expr body ^\")\"\n  | App(e1,e2) -> \"App(\"^string_of_expr e1 ^\",\" ^ string_of_expr e2^\")\"\n  | IsZero(e) -> \"Zero?(\"^string_of_expr e ^\")\"\n  | ITE(e1,e2,e3) -> \"IfThenElse(\"^string_of_expr e1^\",\" ^ string_of_expr e2^\",\" ^ string_of_expr e3  ^\")\"\n  | Letrec(tRes,x,param,tPara, def,body) -> \"Letrec(\"^string_of_texpr\n  tRes^\" \"^x^\",\"^param^\":\"^string_of_texpr tRes ^\",\"^ string_of_expr def ^\",\"^ string_of_expr body ^\")\"\n\n  (* pair *)\n  | Pair(e1, e2) -> \"Pair(\"^(string_of_expr e1)^\"*\"^string_of_expr e2 ^ \")\"\n  | Unpair(id1, id2, e_pair, e_body) -> \"Unpair((\" ^ id1 ^ \",\" ^ id2 ^ \")= \" ^(string_of_expr e_pair) ^ \" in \" ^ string_of_expr e_body ^\")\"\n\n  (* list *)\n  | EmptyList(te) -> \"EmptyList(\" ^ string_of_texpr te ^ \")\"\n  | Cons(he, te) -> \"Cons(\" ^ (string_of_expr he) ^ \"*\" ^ string_of_expr te^ \")\"\n  | Null(e) -> \"Null(\" ^ string_of_expr e ^ \")\"\n  | Hd(e) -> \"Tl(\" ^ string_of_expr e ^ \")\"\n  | Tl(e) -> \"Tl(\" ^ string_of_expr e ^ \")\"\n\n  (* tree *)\n  | EmptyTree(te) -> \"EmptyTree(\" ^ string_of_texpr te ^ \")\"\n  | Node(data, lst, rst) -> \"Node(\" ^ (string_of_expr data) ^ \",\" ^ (string_of_expr lst) ^ \",\" ^ (string_of_expr rst) ^ \")\"\n  | NullT(e) -> \"NullT(\" ^ (string_of_expr e) ^ \")\"\n  | GetData(e) -> \"GetData(\" ^ (string_of_expr e) ^ \")\"\n  | GetLST(e) -> \"GetLST(\" ^ (string_of_expr e) ^ \")\"\n  | GetRST(e) -> \"GetRST(\" ^ (string_of_expr e) ^ \")\"\n\n  | Set(x,rhs) -> \"Set(\"^x^\",\"^string_of_expr rhs^\")\"\n  | BeginEnd(es) -> \"BeginEnd(\" ^ List.fold_left (fun x y -> x^\",\"^y)\n                      \"\" (List.map string_of_expr es) ^\")\"\n\n  | Debug -> \"Debug\"\nand string_of_texpr = function\n  | IntType -> \"int\"\n  | BoolType -> \"bool\"\n  | FuncType(t1,t2) -> \"(\"^string_of_texpr t1^\"->\"^string_of_texpr t2^\")\"\n  | RefType(t) -> \"Ref(\"^string_of_texpr t^\")\"\n  (* TODO: UnitType\n   *       PairType\n   *       ListType\n   *       TreeType *)\n  | _ -> failwith \"TODO: implement me\"\n\nlet string_of_prog (AProg e)  = string_of_expr e\n\n\n"}}}
Found a `.merlin` file at C:\cygwin64\home\StevensUser\cs496\4_TypeCheck
]] Making a new jbuilder package at C:\cygwin64\home\StevensUser\cs496\4_TypeCheck
