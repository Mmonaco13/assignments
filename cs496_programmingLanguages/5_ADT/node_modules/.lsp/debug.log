Hello from C:\Users\StevensUser\.atom\packages\ide-reason\rls\rls-win32-1.4.1.exe
Previous log location: C:\Users\STEVEN~1\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"refmt":"refmt","lispRefmt":"lispRefmt","format_width":80,"autoRebuild":true,"per_value_codelens":false,"dependencies_codelens":false,"opens_codelens":false}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///C:/cygwin64/home/StevensUser/cs496/5_ADT/interp.ml","languageId":"ocaml","version":1,"text":"open Ast\nopen Ds\n\nlet from_some = function\n  | None -> failwith \"from_some: None\"\n  | Some v -> v\n\nlet g_store = Store.empty_store 20 (NumVal 0)\n\nlet init_env =\n  ExtendEnv(\"i\", RefVal (Store.new_ref g_store (NumVal 1)),\n   ExtendEnv(\"v\",RefVal (Store.new_ref g_store (NumVal 5)),\n    ExtendEnv(\"x\",RefVal (Store.new_ref g_store (NumVal 10)),\n      EmptyEnv)))\n\nlet rec new_env en idList args =\nmatch (idList,args) with\n| ([],[]) -> en\n| (x::xs, y::ys) -> (extend_env (new_env en xs ys) x y)\n| _ -> failwith \"Different number of arguments and IDs\"\n\nlet rec apply_branch en branch tag args =\n  match branch with\n  | [] -> failwith \"No branches match\"\n  | Branch(id, idList, ex)::xs when tag = id ->\n    if List.length(idList) = List.length(args)\n    then eval_expr (new_env en idList args) ex\n    else apply_branch en xs tag args\n  | Branch(id, idList, ex)::xs -> apply_branch en xs tag args\nand\nargs_to_vals en x =\n  match x with\n  |[] -> []\n  |l::ls -> (eval_expr en l)::(args_to_vals en ls)\nand\napply_proc f a =\n  match f with\n  | ProcVal (x,b,env) ->\n     eval_expr (extend_env env x a) b\n  | _ -> failwith \"apply_proc: Not a procVal\"\nand\n  eval_expr (en:env) (e:expr) :exp_val =\n  match e with\n  | Int n          -> NumVal n\n  | Var id          ->\n    (match apply_env en id with\n    | None -> failwith @@ \"Variable \"^id^\" undefined\"\n    | Some ev ->  ev)\n  | Unit -> UnitVal\n  | ITE(e1, e2, e3)    ->\n    let v1 = eval_expr en e1 in\n    if boolVal_to_bool v1\n    then eval_expr en e2\n    else eval_expr en e3\n  | Add(e1, e2)    ->\n    let v1 = eval_expr en e1 in\n    let v2 = eval_expr en e2  in\n    NumVal ((numVal_to_num v1) + (numVal_to_num v2))\n  | Mul(e1, e2)    ->\n    let v1 = eval_expr en e1 in\n    let v2 = eval_expr en e2  in\n    NumVal ((numVal_to_num v1) * (numVal_to_num v2))\n  | Sub(e1, e2)    ->\n    let v1 = eval_expr en e1 in\n    let v2 = eval_expr en e2  in\n    NumVal ((numVal_to_num v1) - (numVal_to_num v2))\n  | IsZero(e) ->\n    let v1 = eval_expr en e  in\n    BoolVal (numVal_to_num v1=0)\n  | Let(x, e1, e2) ->\n    let v1 = eval_expr en e1\n    in eval_expr (extend_env en x v1) e2\n  | Proc(x,t,e)      -> ProcVal (x,e,en)\n  | App(e1,e2)     ->\n    let v1 = eval_expr en e1 in\n    let v2 = eval_expr en e2 in\n    apply_proc v1 v2\n  | Letrec(tparam,id,param,tbody,body,e) ->\n    eval_expr (ExtendEnvRec(id,param,body,en)) e\n  | Set(id,e) ->\n    let v=eval_expr en e\n    in Store.set_ref g_store (refVal_to_int (from_some (apply_env en id))) v;\n       NumVal 28\n  | BeginEnd(es) ->\n    List.fold_left (fun v e -> eval_expr en e) (NumVal 28) es\n  | NewRef(e) ->\n    RefVal(Store.new_ref g_store (eval_expr en e))\n  | DeRef(e) ->\n    let v1 = eval_expr en e\n    in Store.deref g_store (refVal_to_int v1)\n  | SetRef(e1,e2) ->\n    let v1=eval_expr en e1\n    in let v2=eval_expr en e2\n    in Store.set_ref g_store (refVal_to_int v1) v2;\n    UnitVal\n  | TypeDecl(id,cs) -> UnitVal\n  | Variant(tag,args) -> TaggedVariantVal(tag, args_to_vals en args)\n  | Case(cond,branches) -> let e1 = eval_expr en cond in\n    (match e1 with\n     | TaggedVariantVal(tag, args) ->\n       apply_branch en branches tag args\n     | _ -> failwith \"Expected a Tagged Variant Val\")\n  | Debug ->\n    print_string \"Environment:\\n\";\n    print_string @@ string_of_env en;\n    print_string \"\\nStore:\\n\";\n    List.iteri (fun i s -> print_string (string_of_int i^\"->\"\n                                                 ^s^\"\\n\")) @@ List.map\n      string_of_expval @@ Store.store_to_list g_store;\n    UnitVal\n  | _ -> failwith(\"Not implemented: \"^string_of_expr e)\nand\n  eval_prog (Ast.AProg e) = eval_expr init_env e\n\n\n\n(***********************************************************************)\n(* Everything above this is essentially the same as we saw in lecture. *)\n(***********************************************************************)\n\n(* Parse a string into an ast *)\n\n\nlet parse s =\n  let lexbuf = Lexing.from_string s in\n  let ast = Parser.prog Lexer.read lexbuf in\n  ast\n\n\n(* Interpret an expression *)\nlet interp (e:string) : exp_val =\n  e |> parse |> eval_prog\n\n(*let test (n:int) : string =\n  Examples.example n |> parse |> eval_prog\n*)\nlet ex1 = \"\nlet x = 7\nin let y = 2\n   in let y = let x = x-1\n              in x-y\n      in (x-8)- y\"\n\nlet ex2 = \"\n   let g =\n      let counter = 0\n      in proc(d) {\n         begin\n           set counter = counter+1;\n           counter\n         end\n         }\n   in (g 11)-(g 22)\"\n\nlet ex3 = \"\n  let g =\n     let counter = newref(0)\n     in proc (d) {\n         begin\n          setref(counter, deref(counter)+1);\n          deref(counter)\n         end\n       }\n  in (g 11) - (g 22)\"\n\nlet ex4 = \"\n   let g =\n      let counter = 0\n      in proc(d) {\n         begin\n           set counter = counter+1;\n           counter\n         end\n         }\n   in debug\"\n\nlet ex5 = \"\nlet a = 3\nin let p = proc(x) { set x = 4 }\nin begin\n         (p a);\n         a\n       end\"\n"}}}
