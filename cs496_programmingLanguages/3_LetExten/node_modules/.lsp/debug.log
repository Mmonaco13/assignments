Hello from C:\Users\StevensUser\.atom\packages\ide-reason\rls\rls-win32-1.4.1.exe
Previous log location: C:\Users\STEVEN~1\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"refmt":"refmt","lispRefmt":"lispRefmt","format_width":80,"autoRebuild":true,"per_value_codelens":false,"dependencies_codelens":false,"opens_codelens":false}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///C:/cygwin64/home/StevensUser/cs496/3_LetExten/interp.ml","languageId":"ocaml","version":1,"text":"(***********************************************************************)\n(* Matthew Monaco\n   I pledge my honor that I have abided by the Stevens Honor System    *)\n(***********************************************************************)\nopen Ast\nopen Ds\n\nlet rec eval (en:env) (e:expr):exp_val =\n  match e with\n  | Int n           -> NumVal n\n  | Var x           -> lookup en x\n  | Let(x, e1, e2)  ->\n    let v1 = eval en e1  in\n    eval (extend_env en x v1) e2\n  | IsZero(e1)      ->\n    let v1 = eval en e1  in\n    let n1 = numVal_to_num v1 in\n    BoolVal (n1 = 0)\n  | ITE(e1, e2, e3) ->\n    let v1 = eval en e1  in\n    let b1 = boolVal_to_bool v1 in\n    if b1 then eval en e2 else eval en e3\n  | Sub(e1, e2)     ->\n    let v1 = eval en e1 in\n    let v2 = eval en e2  in\n    NumVal ((numVal_to_num v1) - (numVal_to_num v2))\n  | Add(e1, e2) ->\n    let v1 = eval en e1 in\n    let v2 = eval en e2  in\n    NumVal ((numVal_to_num v1) + (numVal_to_num v2))\n  | Div(e1, e2) ->\n    let v1 = eval en e1 in\n    let v2 = eval en e2  in\n    NumVal ((numVal_to_num v1) / (numVal_to_num v2))\n  | Mul(e1, e2) ->\n    let v1 = eval en e1 in\n    let v2 = eval en e2  in\n    NumVal ((numVal_to_num v1) * (numVal_to_num v2))\n  | Abs(e1) ->\n    let n1 = eval en e1 in\n    (match n1 with\n    | NumVal(n) ->\n      if n > 0\n      then NumVal n\n      else NumVal (-1 * n)\n    | _ -> failwith(\"Expected a Num\"))\n  | Cons(e1, e2) ->\n    let n1 = eval en e1 in\n    let n2 = eval en e2 in\n    (match n2 with\n    | ListVal(n) -> ListVal(n1::n)\n    | _ -> failwith(\"Expected a List\"))\n  | Hd(e1) ->\n    let n1 = eval en e1 in\n    (match n1 with\n    | ListVal(n) -> List.hd n\n    | _ -> failwith(\"Expected a List\"))\n  | Tl(e1) ->\n    let n1 = eval en e1 in\n    (match n1 with\n    | ListVal(n) -> ListVal(List.tl n)\n    | _ -> failwith(\"Expected a List\"))\n  | Empty(e1) -> (* supports both lists and trees *)\n    let n1 = eval en e1 in\n    (match n1 with\n    | ListVal(n) ->\n      if n = []\n      then BoolVal true\n      else BoolVal false\n    | TreeVal(t) ->\n      if t = Empty\n      then BoolVal true\n      else BoolVal false\n    | _ -> failwith(\"Expected a List or Tree\"))\n  | EmptyList -> ListVal []\n  | EmptyTree -> TreeVal Empty\n  | Node(e1,lt,rt) ->\n    let n1 = eval en e1 in\n    let ltr = eval en lt in\n    let rtr = eval en rt in\n    (match ltr,rtr with\n    | TreeVal(l),TreeVal(r) -> TreeVal (Node(n1,l,r))\n    | _ -> failwith(\"Expected a Tree\"))\n  | CaseT(target,emptycase,id_e,id_lt,id_rt,nodecase) ->\n    let e1 = eval en target in\n    (match e1 with\n    | TreeVal(Empty) -> eval en emptycase\n    | TreeVal(Node(ev1,ev2,ev3)) ->\n      let nEnv =\n      (extend_env\n        (extend_env\n          (extend_env en id_e ev1)\n        id_lt (TreeVal ev2))\n      id_rt (TreeVal ev3)) in\n      eval nEnv nodecase\n    | _ -> failwith(\"Expected a Tree\"))\n\n\n(***********************************************************************)\n(* Everything above this is essentially the same as we saw in lecture. *)\n(***********************************************************************)\n\n(* Parse a string into an ast *)\nlet parse s =\n  let lexbuf = Lexing.from_string s in\n  let ast = Parser.prog Lexer.read lexbuf in\n  ast\n\n\n(* Interpret an expression *)\nlet interp (e:string):exp_val =\n  e |> parse |> eval (empty_env ())\n"}}}
Found a `.merlin` file at C:\cygwin64\home\StevensUser\cs496\3_LetExten
]] Making a new jbuilder package at C:\cygwin64\home\StevensUser\cs496\3_LetExten
